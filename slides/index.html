<!DOCTYPE html>
<html lang="en">
<head>
    <title>TypeScript presentation</title>
    <meta charset="utf-8">
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <style>
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    </style>
    <link rel="stylesheet" type="text/css" href="../css/slides.css">
</head>
<body>
<textarea id="source">

class: center, middle
background-image: url(../images/title-folie.jpeg)

.title[
<br/><br/><br/><br/><br/><br/><br/>
### Rowing Session at Fincons Group AG, 25.06.2020
### Speaker: Oleg Varaksin
]

???

Ziel der Präsentation: Einführung in TypeScript zu geben, aber auch tiefe Einblicke hinter die Kulissen.
Nach der heutigen Rowing-Session solltet ihr in der Lage sein, Software mit TypeScript zu schreiben.
    
---
    
# About Speaker

  - __Current job__: Fullstack Senior Software-Developer / Architect at SBB
  - __Current project__: SmartRail 4.0, TMS-L, real-time GUIs (web and mobile)
  - __Main interests__: Frontend technologies: JavaScript based web frameworks, TypeScript, Angular, RxJS, WebGL
  - __E-mail__: ovaraksin@googlemail.com
  - __GitHub__: https://github.com/ova2
  - __Medium__: https://medium.com/@OlegVaraksin
  - __Twitter__: https://twitter.com/OlegVaraksin
  - __Books__:
    - <a href="https://packtpub.com/application-development/primefaces-cookbook-second-edition" target="_blank">PrimeFaces Cookbook</a>, Packt Publishing
    - <a href="https://packtpub.com/web-development/angular-ui-development-primeng" target="_blank">Angular UI Development with PrimeNG</a>, Packt Publishing

???

Letztes Buch: habe eine kurze Einfrührung in TS gegeben und werde einige Code-Beispiele aus diesem Buch in dieser Präsentation verwenden.

---

# Introduction

- TypeScript (http://typescriptlang.org) is a typed language and a super set of JavaScript.
  It was designed and developed by Microsoft (Anders Hejlsberg).

- TypeScript is an advanced JavaScript with optional static typing.
  Static typing is optional because __every JavaScript program is also a TypeScript program__.

- TypeScript code is not processed by browsers, it has to be translated into JavaScript by means of a TypeScript compiler.
  This translation is called _compilation_ or _transpilation_.

- TypeScript is an object oriented language with OO patterns.

- It can be used on the client as well as server side.

???

- Wir werden noch gleich sehen, in welcher Beziehung TypeScript zu JavaScript steht.
- Anders Hejlsberg ist der Vater von TS and ist massgebend an der Entwicklung beteiligt (kennt ihr ihn?).
- zu OO: aber natürlich ist auch möglich, in TS funktional zu programmieren, ohne OOP.
  TS ist ja ein Superset von JS, wo man normalerweise funtktional programmiert.

---

# Main advantages of TypeScript

- Types help you find and fix a lot of errors during development time. That means, you have less errors at runtime.

- Many modern ECMAScript features are supported out of the box.
  More features are expected according to the roadmap (https://github.com/Microsoft/TypeScript/wiki/Roadmap).

- Great tooling and IDE support with IntelliSense makes the coding a pleasure.

- It is easier to maintain and refactor a (large) TypeScript application than one written in untyped JavaScript.
  It makes our code more consistence, clean and reusable.

- Developers feel comfortable with TypeScript due to object-oriented programming patterns, such as interfaces, classes, enums, generics, and so on.

???

- Was heisst "supported out of the box"? TS kompiliert den Code so, dass auch die modernen Features unterstützt werden,
 welche in eurem Browser (wo das Program läuft) nicht unterstützt sind.
- Auto-completion in einem Projekt demonstrieren.
- Für die Entwicklugn und Wartung von grossen Projekten ist es von Vorteil, TS zu wählen (als JS).
- Fazit: Produktivität und die Entwicklungszeit steigen mit TypeScript.

---

# What is the best way to learn the TypeScript language?

_Recommended reference sources_

- <a href="https://www.typescriptlang.org/docs/handbook/">TypeScript Handbook</a>
- <a href="https://basarat.gitbook.io/typescript/">TypeScript Deep Dive by Basarat Ali Syed</a>
- <a href="https://www.amazon.de/Programming-TypeScript-Boris-Cherny/dp/1492037656/">Book: Programming TypeScript: Making Your JavaScript Applications Scale, written by Boris Cherny</a>
- <a href="https://www.oreilly.com/library/view/effective-typescript/9781492053736/">Book: Effective TypeScript, written by Dan Vanderkam</a>

_Additional reading_

- <a href="https://mariusschulz.com/blog">Marius Schulz Blog</a>
- <a href="https://www.oreilly.com/library/view/typescript-design-patterns/9781785280832/">Book: TypeScript Design Patterns, written by Vilic Vane</a>
- <a href="https://refactoring.guru/design-patterns/typescript">Design Patterns in TypeScript</a>

---

# Relationship between TypeScript and JavaScript

![100%](../images/typescript-superset-js.png)

- The _Typescript Language Specification_ says, every JavaScript program is also a TypeScript program.
  Hence, a migration from JavaScript to TypeScript code is easily done.
- Converse is not true: there are TypeScript programs which are not JavaScript programs.

???

- TS bringt die Typisierung und erweitert die Sprachkonstrukte von JS um zusätzliche Syntax für spezifizierte Typen,
  wie beispielsweise Interfaces, Enums, usw.

---

# Relationship between TypeScript and JavaScript

Valid TypeScript program:

```ts
function greet(who: string) {
  console.log('Hello', who);
}
```

Result when it gets executed as an JavaScript program:

```ts
function greet(who: string) {
                  ^
SyntaxError: Unexpected token ':'
```

Reason:

The `: string` is a type annotation that is specific to TypeScript.

???

Oben ist ein gültiges TS Programm. Wenn wir aber diesen Code als JS (z.B. in Browser) ausführen lassen,
wird es ein SyntaxError gemeldet. Grund dafür ist : string ist eine type annotation, welche spezifisch zu TS ist.

---

# Relationship between TypeScript and JavaScript

Per default, TypeScript compiler __emits output (JavaScript) even when any errors are reported__.

Even if your JavaScript code doesn't throw any errors, it still might not do what you intend. Example:

```js
const states = [
  {name: 'Alabama', capital: 'Montgomery'}
  {name: 'Arizona', capital: 'Phoenix'}
  // ...
]
for (const state of states) {
  console.log(state.capitol);
}
```

This is a valid JavaScript programm which will log:

```
undefined
undefined
```

???

- Wie werden aber sehen, dass man das Output von fehlerhaftem JavaScript-Code durch eine Compiler-Option unterbinden kann.
Compiler-Optionen steuern den Kompilierprozess und man kann z.B. sagen "generiere kein JavaScript, wenn TS Compiler irgendwelche Fehler entdeckt hat".
- Frage: was ist falsch in diesem Code?

---

# Relationship between TypeScript and JavaScript

Let's compile the code with TypeScript.

Even without adding type annotations, TypeScript type checker is able to spot the error and offer a helpful suggestion.

```ts
const states = [
  {name: 'Alabama', capital: 'Montgomery'}
  {name: 'Arizona', capital: 'Phoenix'}
  // ...
]
for (const state of states) {
  console.log(state.capitol);
    // ~~~~ Property 'capitol' does not exist on type
    //      '{ name: string; capital: string; }'.
    //      Did you mean 'capital'?
}
```

---

# Relationship between TypeScript and JavaScript

TypeScript's type system models the runtime behavior of JavaScript. This may result in some suprises if you' re coming from a laguage
with stricter runtime checks. Example:

```ts
const x = 2 + '3';  // OK, type is string
```

The statement passes the type checker, even though they do produce runtime errors in many other languages.
This does model the runtime behavior of JavaScript, where the the expression results in the string `"23"`.

On the other hand, TypeScript compiler is stronger than the runtime behavior of JavaScript. Example:

```ts
const a = null + 7;  // Evaluates to 7 in JS
    // ~~~~ Operator '+' cannot be applied to types ...
```

???

- Das Laufzeit-Verhalten von JavaScript kann euch überraschen, wenn ihr bis jetzt in den strikten Programmiersprachen,
  wie Java oder C# programmiert haben.

---

# Relationship between TypeScript and JavaScript

If you program type checks, could it still throw an error at runtime?

???

Quiz: Wenn ein TS program das Type Checking überstanden hat, kann es eine Exception zur Laufzeit werfen? Was denkt ihr?

--

The answer is "yes". Here's an example:

```ts
const names = ['Alice', 'Bob'];
console.log(names[2].toUpperCase());
```

When you run this, it throws

```ts
TypeError: Cannot read property 'toUpperCase' of undefined
```

TypeScript assumed the array access would be within bounds, but it was not. This assumption led to an error at runtime.

---

# Code generation

TypeScript files use a __.ts__ (or __.tsx__) extension, rather than the __.js__ (or __.jsx__) extension of a JavaScript file.

![100%](../images/transpiling.jpg)

__Target__ signifies which target of JavaScript should be emitted from the given TypeScript.

???

Der Compiler kompiliert / transpiliert den TS Code in JS Code. Dabei kann das Target via Compiler-Options angegeben werden.
Nicht alle Browser unterstützen die modernen JavaScript Features. Mittels Target kann ich meine Browser-Platform auswählen,
wo mein Program nachher läuft. Die wichtigsten Kompileroptionen und wo man sie angibt, werden wir noch kennenlernen.
An dieser Stelle möchte ich aber dennoch ein Beispiel für die Target-Option geben.

---

# Code generation

__target: es5__

```ts
() => null
```

will become

```js
function() {return null}
```

as ES5 doesn't have arrow functions.

__target: es6__

```ts
() => null
```

will become

```js
() => null
```

as ES6 has arrow functions.

---

# Installation and Output

You can install TypeScript via `npm` globally in the command line:

```
npm install -g typescript
```

Global installation means, the TypeScript compiler __tsc__ can be reached and used in any of your projects.
Installed <a href="https:/nodejs.org">Node.js</a> and npm are presupposed. Node.js is the JavaScript runtime
environment. npm is the package manager. It is shipped with Node.js, but can be installed separately as well.

After that, you can transpile one or more __.ts__ files into __.js__ files by typing:

```
tsc some.ts another.ts
```

This will result in two files, `some.js` and `another.js`.

TypeScript can also be installed locally (below your project root) by typing

```
npm install --save-dev typescript
```

It writes the typescript into your `package.json`.

???

- Globale Installation heisst, der TS Compiler kann von jeder Stelle / jedem Verzeichniss in der Command Line angesprochen werden.
- Lokalle Installation installiert den Compiler im Projekt selbst unter node_modules Verzeichnis.
  Zeigen IntelliJ Settings für TS in einem Projekt + node_modules.

---

# Learning TypeScript Playground

Hands-on learning is possible with the <a href="https://www.typescriptlang.org/play/">TypeScript playground</a> which
which compiles on-the-fly TypeScript code entered in a browser and shows it side by side with the generated JavaScript code.

![100%](../images/playground.png)

???

MS hat stellt einen TS Playground zur Verfügung, mit dessen Hilfe TS Code Snippets direkt ausprobiert werden können.
Auf der linken Seite kann man die TS Snippets eingeben und auf der rechten Seite sieht man den generierten JS Code.
Im Playground selbst kann folgende Einstellungen vornehmen:
- TS Version auswählen
- Fertige Beispiele auswählen. Classes auswählen.
- Kompileroptionen einstellen. Den JS Code für Klassen mit den Targets ES5 und ES6 zeigen (Unterschied).
- Code in der Browser Console laufen lassen (Run = Ctrl + Enter). Console mit F12 öffnen.

---

# Primitive types

TypeScript exposes the basic types, as well as a couple of extra types. Let's explore the type system with examples.

__boolean__. The type is a primitive JavaScript boolean.

```ts
let success: boolean = true;
```

__number__. The type is a primitive JavaScript number.

```ts
let count: number = 20;
```

__string__. The type is a primitive JavaScript string.

```ts
let message: string = "Hello world";
```

---

# Primitive types

__Array__. The type is an array of value. There are two equivalent notations.

```ts
let ages: number[] = [31, 20, 65];
let ages: Array<number> = [31, 20, 65];
```

__Tuple__. The type represents a heterogeneous array of values. Tuple enables storing multiple fields of different types.

```ts
let x: [string, number];
x = ["age", 40];  // ok
x = [40, "age"] ; // error
```

__object__. The type represents the non-primitive type, i.e. anything that is not `number`, `string`, `boolean`, `bigint`, `symbol`, `null`, or `undefined`.

__Attention:__ There is `object` (lowercased) and `Object` (uppercased)!

- `object` represents all non-primitive types.
- `Object` describes functionality that is common to all JavaScript objects, e.g. the methods `toString()`, `hasOwnProperty()`, etc.

???

- Bei Arrays tendiere ich persönlich zu der 1. Schreibweise
- Tuples erlauben Array Definitionen mit unterschiedlichen Typen einzelner Elementen

---

# Primitive types

Example of usage of `object`:

The `Object.create()` method specifies the type `object | null` for its parameter:

```ts
interface ObjectConstructor {
  // Creates an object that has the specified prototype or
  // that has null prototype.
  create(o: object | null): any;
  ...
}
```

Examples:

```ts
Object.create(proto);     // OK
Object.create(null);      // OK -> creates "pure" object
Object.create(undefined); // Error
Object.create(1337);      // Error
Object.create(true);      // Error
Object.create("oops");    // Error
```

???

Kennt ihr die Methode create()? Die Methode create des Konstruktors Object erzeugt ein neues gewöhnliches Objekt.
Der Prototyp des erzeugten Objektes ist der Wert, welcher der Methode beim Aufruf als erstes Argument übergeben wurde.
D.h. das erzeugte Objekt erbt alles von dem übergebenen Objekt (vom Prototype des übergebenen Objektes, alle Properties und Methoden).

---

# Types void, null and undefined

__void__. The type represents the absence of having any type. This type is normally used as the return type of functions.

```ts
function doSomething(): void {
  // do something
}
```

__undefined__ and __null__. These types represents `undefined` and `null` respectively.

```ts
// undefined means, the value hasn't been initialized
let u: undefined = undefined;
// null means, the value is currently unavailable
let n: null = null;
```

Per default, `null` and `undefined` are valid values of every type. That means, they can be assigned to any other type.

```ts
let x: string = "foo";
x = null; // ok
```

???

Wir werden später sehen, wie dieses Default-Verhalten mit Hilfe von Compiler-Optionen geändert werden kann.

---

# Difference between any, unknown and never

__any__. The type is anything. It is useful when you need to describe the type of variables that you do not know
at the time of writing your application. You can assign a value of arbitrary type to a variable of type `any`.
A value of type `any` in turn can be assigned to a variable of arbitrary type.

```ts
let some: any = "some";
some = 10000;
some = false;

let success: boolean = some;
let count: number = some;
let message: string = some;
```

When to use `any` type in TypeScript? Due to the nature of JavaScript, in some cases providing accurate types isn't a simple task.
Use the `any` when there no type definitions available for that particular piece of code you're working with.

???

any sollte nur in Ausnahmefällen benutzt werden,
wenn der Type wirklich nicht bekannt / nicht aus dem existierenden Code abgeleitet werden kann.

---

# Difference between any, unknown and never

- `any` disables the type checker => there's no type safety with `any` type. Compare two code pieces:

```ts
let age: number;
age = 12;
age += 1;  // age = 13
```

```ts
let age: any;
age = '12';
age += 1;  // no errors at runtime, but age is now "121"
```

- `any` lets you break contracts. When you write a function, you are specifying a contract for expected input and output.
But with `any` you can break these contracts. E.g.

```ts
function calculateAge(birthDate: Date): number { ... }

let birthDate: any = '1990-01-19';
calculateAge(birthDate); // OK at compile time,
                         // but can produce error at runtime
```

???

Warum is any type mit Vorsicht zu geniessen? Any birgt viele Nachteile in sich. Nur zwei Beispiele.

---

# Difference between any, unknown and never

TypeScript 3.0 introduced a new `unknown` type which is the type-safe counterpart of the any type.
The main difference between `unknown` and `any` is that `unknown` is much less permissive than `any`:
we have to do some form of checking before performing most operations on values of type `unknown`.

- Common part for `any` and `unknown`: just like all types are assignable to `any`, all types are assignable to `unknown`.

```ts
let value: unknown;
value = true;             // OK
value = 42;               // OK
value = "Hello World";    // OK
value = [];               // OK
value = {};               // OK
value = Math.random;      // OK
value = null;             // OK
value = undefined;        // OK
value = new TypeError();  // OK
value = Symbol("type");   // OK
```

???

- unknown ist nicht so tolerant oder freizügig als any und bringt mehr Typesicherheit ins Spiel.
- unknown zwingt die Entwickler mehr Prüfungen hinsichtlich der Typen zu machen, bevor man einen Wert vom Typ unknown überhaupt verwendet.
- unknown hat sowohl die Gemeinsamkeiten, als auch die Unterschiede zu any.

---

# Difference between any, unknown and never

- Different part between `any` and `unknown`: the `unknown` type is only assignable to the `any` type and the `unknown` type itself.

```ts
let value: unknown;
let value1: unknown = value;   // OK
let value2: any = value;       // OK
let value3: boolean = value;   // Error
let value4: number = value;    // Error
let value5: string = value;    // Error
let value6: object = value;    // Error
let value7: any[] = value;     // Error
let value8: Function = value;  // Error

// Furthermore, none of the operations
// are considered type-correct anymore!
// Examples:
value.trim();   // Error
value();        // Error
value[0];       // Error
```

---

# Difference between any, unknown and never

__Main advantage of unknown__

This is useful for APIs that want to signal
"this can be any value, so you must perform some type of checking before you use it".
This forces users to safely introspect returned values.

```ts
// Type assertion to rescue
const value: unknown = "Hello World";
(value as string).toUpperCase();  // "HELLO WORLD"
```

When to use:

- when the client gets a response from backend and data type is unknown.
- when the client reads the data from browser's persistence storage.
- ...

???

- Um mit `unknown` vernüftig ohne Compiler-Fehler zu arbeiten, ist der Entwickler dazu gezwungen,
  über den Type nachzudenken und type assertions to verwenden (werden weiter kennenlernen).
- In TS playground probieren:
  ```ts
  const value: unknown = "Hello World";
  console.log(value.toUpperCase());
  console.log((value as string).toUpperCase());
  ```
- Wann sollte unknown benutzt werden?
  - Z.B. wenn man die Daten vom Server in HTTP-Response bekommt und der Typ der Daten nicht bekannt ist (unknown zu benutzen ist hier sicherer als any)
  - Wenn man die Daten aus dem Browser Persistence-Storage liest. Im einfachsten Fall liest man die Daten mit localeStorage (blocking API: getItem, setItem).

---

# Difference between any, unknown and never

__never__. The `never` type represents the type of values that never occur. For instance,
`never` is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns.

```ts
function error(message: string): never {
  throw new Error(message);
}
```

```ts
function infiniteLoop(): never {
  while (true) {
  }
}
```

- The `never` type is assignable to every type.
- However, no type is assignable to `never` (except never itself). Even `any` isn't assignable to never.

---

# Difference between any, unknown and never

__Summary__

Types `any`, `unknown` and `never` at a glance.

![100%](../images/any-unknown-never.png)

???

Wie gesagt, any hebelt den Type-Checker komplett aus und bringt die meiste Freiheit hier.
Aber any bringt auch die meiste Typunsicherheit und die Laufzeitfehler mit.
Programmieren mit any in TS ist mit dem Programmieren in pure JS gleichgestellt. Alle Vorteile einer typisierten Sprache gehen verloren!

---

# Enums

Enums allow us to define a set of named constants. There are Numeric, String and Heterogeneous enums.

__Numeric enums__

Enum members have numeric values associated with them (started with 0):

```ts
enum Color {
  Red,
  Green,
  Blue
}

let color = Color.Red; // color has value 0
```

__String enums__

```ts
enum Direction {
  Up = "UP",
  Down = "DOWN"
}
```

???

- Vorteil von String enums liegt auf der Hand. Die Werte sind aussagekräftiger als bei numerischen enums, was beim Debugging sehr hilft.
- Heterogener enum vereint Numeric und String enums (man kann beide mischen). TS empfielt diese Enums zu vermeiden;
  es ist nicht klar, wo sie überhaupt nützlich sind.
- JS Code von enum Color in Playground zeigen. Zeigen versteckte Features:
  ```
  console.log(Color["Blue"]);
  console.log(Color[2]);
  ```

---

# Interfaces


---

# Classes


---

# Public, private, and protected modifiers


---

# Modules


---

# Meet TypeScript compiler options. noImplicitAny.


---

# Meet TypeScript compiler options. strictNullChecks.

We have seen the default behavior when setting nullable types `null` and `undefined`. For example:

```ts
let x: number;
x = 1;         // ok
x = undefined; // ok
```

It is not always desired. TypeScript offers a possibility to change this default behavior by setting the compiler options
`--strictNullChecks` to `true`. With this option set, you have to include these types explicitly using a union type (explained later on),
otherwise, you will get an error. Example:

```ts
let x: string = "foo";
x = null; // error
let y: string | null = "foo";
y = null; // ok
```

Benefit: This helps avoid many common errors!

---

# Structural typing

---

# Difference between type and interface

---

# Type assertions

Sometimes, you would like to tell compiler that you know the type better than it does and it
should trust you. For instance, imagine a situation where you receive data over HTTP and
know exactly the structure of the received data. The compiler doesn't know such structure
of course. In this case, you want to turn off the type checking when assigning the data to a
variable. It is possible with so called __type assertions__. Type assertion is like a type cast in
other languages, but without the checking of data. You can do that either with _angle bracket_
or the _as_ syntax.

```ts
let element = <HTMLCanvasElement> document.getElementById('canvas');
let element = document.getElementById('canvas') as HTMLCanvasElement;
```

TODO

---

# Type inference

---
class: center, middle, inverse
    
# That's all folks, thanks for your attention!
    
.back[[Back to the homepage](https://ova2.github.io/typescript-rowing-session/)]
   
Slideshow created with [remark](https://github.com/gnab/remark)
    
</textarea>
<script>
    var slideshow = remark.create({
        highlightLanguage: 'typescript', highlightStyle: 'railscasts', navigation: {scroll: false}
    });
</script>
</body>
</html>
